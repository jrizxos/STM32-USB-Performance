# STM32-USB-Performance
This is a project to measure the bandwidth of the USB2.0 periferal in STM32 microprocessors. We used the Continuous Transmit program to measure the bandwidth of Bulk USB Transfers for different message lengths and different workloads on a Nucleo F767zi. We also use 2 gpio pins and an oscilloscope to measure the time left to the CPU for more work as the USB peripheral is sending a message. Using the measurements we developed Continuous Transmit Optimized which is the optimal way to continually send messages through USB.

## Contents
- **MXproject:** a CubeMX project file containing the peripheral configuration of F767zi.
- **USB_Continuous_Transmit:** Inc/ and Src/ folders for the USB continuous transmit program for F767zi.
- **USB_Continuous_Transmit_Optimized:** Inc/ and Src/ folders for the optimized continuous transmit program for F767zi.
- **measurements:** raw measurement files.
- **usbspeed.cpp:** a PC program that receives data from the F767zi via USB.
- **STMicroelectronics Liscence.txt:** the license under which the files generated by CubeMX are to be used.

## Using the Code
It is recommended that you use [STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html) to initialize the code for your microprocessor with the configuration included in the CubeMx project file. Then replace the files in the Inc/ and Src/ folders that were generated for the program you want to run. Upload the program to your microprocessor. Compile usbspeed.cpp, you will need libusb1.0 to do this, most Linux distributions come with libusb preinstalled and on Windows you can build it linking the library with Visual Studio. Once both programs are ready connect the microprocessor board to the PC with a USB cable and run usbspeed.

## Configuring the Code
The usbspeed program can receive data with three different functions, only one of them should be called per session. *readprint* is meant to print every message received from the microprocessor for debugging. *readmeasure* measures the bandwidth achieved by the USB by reading a lot of messages over time. *receive* reads messages that contain packets encoded with the Consistent Overhead Byte Stuffing algorithm and measures the bandwidth achieved.
Use *readprint* and *readmeasure* only to read messages from the *USB_Continuous_Transmit* program and *receive* only to read messages from the *USB_Continuous_Transmit_Optimized* program. Each of the three functions requires message size and message limit. The message size should be the same as the message size that the microprocessor program uses. The message limit is there so that the program ends at some point, when measuring bandwidth it is recommended that you set the message limit such that the program reads messages for at least 60 seconds.

On the microprocessor programs you can edit the sent message size and included packet size for USB_Continuous_Transmit_Optimized, using the defines at the beginning of each main.c (*MSG_LEN*, *BUFF_LEN*, *PACKET_LEN*). In *USB_Continuous_Transmit* you can also select one of the workloads and add extra delay to test the microprocessorâ€™s performance.

It is important to note that we have changed the definition of the *CDC_Transmit_FS* function in *usbd_cdc_if.c*: the *Len* parameter was defined as uint16_t but the USB message length register of F767zi can hold up to 19 bits for size, thus we changed it to a uint32_t. *Len* started off as a 16 bit value to restrict the maximum length and then would get casted to 32 bits before the 19 least significant bits get copied with a mask. Refer to your microprocessor's manual to see wether this change can be applied to it, there might be a slight chance you need to change the parameter definition back to uint16_t or even uint8_t.
