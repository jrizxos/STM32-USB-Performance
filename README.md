# STM32-USB-Performance
This is a project to measure the performance of the USB2.0 peripheral in STM32 microprocontrollers. We used a Nucleo F767zi, running the *Continuous Transmit* program, in combination with the usbspeed program running on the host PC, to measure the bandwidth of Bulk USB Transfers that F767zi’s USB2.0 peripheral can achieve. We also use 2 gpio pins and an oscilloscope to measure the time left to the CPU for more work, after preparing a message to be sent, as the USB peripheral is sending a message. 

Using the measurements we developed the *Continuous Transmit Optimized* program, which is the optimal way to continually send messages through USB.


## Contents
- **MXproject:** a CubeMX project file containing the peripheral configuration of F767zi.
- **USB_Continuous_Transmit:** Inc/ and Src/ folders for the USB continuous transmit program for F767zi.
- **USB_Continuous_Transmit_Optimized:** Inc/ and Src/ folders for the optimized continuous transmit program for F767zi.
- **measurements:** raw measurement files.
- **usbspeed.cpp:** a PC program that receives data from the F767zi via USB.
- **STMicroelectronics Liscence.txt:** the license under which the files generated by CubeMX are to be used.

## Using the Code
It is recommended that you use [STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html) to initialize the code for your microprocessor with the configuration included in the CubeMx project file. Then replace the files in the Inc/ and Src/ folders that were generated for the program you want to run. You might need to make some changes on the code, depending on the microprocessor you are using, as STM32 code is only partly compatible between different models. Finally upload the program to your microprocessor. 

Compile usbspeed.cpp, you will need libusb1.0 to do this, most Linux distributions come with libusb preinstalled and on Windows you can build it linking the library with Visual Studio. Once both programs are ready connect the microprocessor board to the PC via USB and run the usbspeed program.

## Configuring the usbspeed program
The usbspeed program can receive data with three different functions, only one of them should be called per session, by uncommenting your preferred function:
- *readprint* is meant to print every message received from the microprocessor for debugging (used only to read messages sent by <ins>*USB_Continuous_Transmit*</ins> program).
- *readmeasure* measures the bandwidth achieved by the USB by reading a lot of messages over time (used only to read messages sent by <ins>*USB_Continuous_Transmit*</ins> program). 
- *receive* reads messages that contain packets encoded with the *Consistent Overhead Byte Stuffing* algorithm and measures the bandwidth achieved (used only to read messages sent by <ins>*USB_Continuous_Transmit_Optimized*</ins> program).

Each of the three functions requires message size and message limit. The message size should be the same as the message size that the microprocessor program uses. The message limit is there so that the program finishes at some point, when measuring bandwidth it is recommended that you set the message limit such that the program reads messages for at least 60 seconds.


## Configuring the microprocessor programs
On the microprocessor programs you can edit the sent message size and included packet size for USB_Continuous_Transmit_Optimized, using the defines at the beginning of each main.c (*MSG_LEN*, *BUFF_LEN*, *PACKET_LEN*). In *USB_Continuous_Transmit* you can also select one of the workloads and add extra delay to test the microprocessor’s performance, by uncommenting your preferred function.


## Notes
It is important to note that we have changed the definition of the *CDC_Transmit_FS* function in *usbd_cdc_if.c*: the *Len* parameter was defined as uint16_t but the USB message length register of F767zi can hold up to 19 bits for size, thus we changed it to a uint32_t. *Len* started off as a 16 bit value to restrict the maximum length and then would get casted to 32 bits before the 19 least significant bits get copied with a mask. Refer to your microprocessor's manual to see wether this change can be applied to it, there might be a slight chance you need to change the parameter definition back to uint16_t or even uint8_t.

For more information please refer to my assignment, *Chapter 3* describes the methodology and code used, *Chapter 4* presents the results of the measurements and *Chapter 5* describes the *USB_Continuous_Transmit_Optimized:* program <ins>Link TBA</ins>
